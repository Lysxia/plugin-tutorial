DECLARE PLUGIN "tuto2_plugin"

{

(*
 * In this exercise, we will extend our Coq plugin from before!
 * Last time, we wrote a plugin that manipulates terms from Coq
 * and then defines new terms. This time, we'll use that same idea
 * to implement a form of proof repair!
 *
 * As always, this will be discussion-based, with the usual format.
 *)
open Stdarg
open Termutils
open Exercise
open Stateutils

(* TODO move etc *)
let print env t sigma = Printer.pr_econstr_env env sigma t

(* TODO move etc *)
let lookup_definition env def sigma =
  let open EConstr in
  match kind sigma def with
  | Constr.Const (c, u) ->
     let cb = Environ.lookup_constant c env in
     (match Global.body_of_constant_body Library.indirect_accessor cb with
      | Some(e, _, _) -> EConstr.of_constr e
      | None -> failwith "This term has no value")
  | _ -> failwith "not a definition"

(* Fully lookup a def in env, but return the term if it is not a definition *)
let rec unwrap_definition env trm sigma =
  try
    let body = lookup_definition env trm sigma in
    if Constr.equal (EConstr.to_constr sigma body) (EConstr.to_constr sigma trm) then
      trm
    else
      unwrap_definition env body sigma
  with _ ->
    trm
}

(*** TODO ***)

(*
 * TODO explain, break down into smaller problems
 *
 * TODO exercise
 *)
VERNAC COMMAND EXTEND DisplayMap CLASSIFIED AS SIDEFF
| [ "Display" "Map" constr(e) ] ->
   {
     let sigma, env = global_env () in
     let sigma, map = internalize env e sigma in
     let sigma, swap_map = get_swap_map env map sigma in
     Feedback.msg_notice
       (Pp.seq
          [Pp.str "This function maps: ";
           Pp.prlist_with_sep
             (fun _ -> Pp.str ", ")
             (fun (c_o, c_n) ->
               Pp.prlist_with_sep
                 (fun _ -> Pp.str " <-> ")
                 (Printer.pr_econstr_env env sigma)
                 [c_o; c_n])
             swap_map])
   }
END

(* TODO explain, break down into smaller problems, handle constants 
   TODO exercise
   TODO debugging info  
   TODO note about when this will break (like when large elim not defined) *)
VERNAC COMMAND EXTEND DefineMap CLASSIFIED AS SIDEFF
| [ "Define" "Map" ident(i) ":=" constr(e) ] ->
   {
     let sigma, env = global_env () in
     let sigma, map = internalize env e sigma in
     let sigma, ip_map = get_swapped_induction_principles env map sigma in
     List.iter2
       (fun (_, ip) suffix ->
         let prefix = Names.Id.to_string i in
         let id = Names.Id.of_string (String.concat "_" [prefix; suffix]) in
         define id ip sigma)
       ip_map
       ["ind"; "rec"; "rect"] 
   }
END

(*** TODO ***)

(*
 * TODO explain, break down into smaller problems
 *
 * TODO exercise
 * TODO something weird with induction principles, whatever
 * TODO for constants, make a variant that calls swap
 *)
VERNAC COMMAND EXTEND Swap CLASSIFIED AS SIDEFF
| [ "Swapped" ident(i) ":=" constr(f) constr(e) ] ->
   {
     let sigma, env = global_env () in
     let sigma, map = internalize env f sigma in
     let sigma, trm = internalize env e sigma in
     let sigma, typ_map = inductives_from_map env map sigma in
     let sigma, swap_map = get_swap_map env map sigma in
     let sigma, ip_map = get_swapped_induction_principles env map sigma in
     let sigma, swapped =
       fold_left_state
         (fun subbed (src, dst) sigma ->
           let sigma, subbed = sub env (src, dst) subbed sigma in
           sigma, reduce_term env subbed sigma)
         (unwrap_definition env trm sigma)
         (List.append (typ_map :: swap_map) (List.rev ip_map))
         sigma
     in Termutils.define i swapped sigma
   }
END

(*** DISCUSSION ***)

(*
 * Same format as usual---please post in the forum as a group!
 * And you need to answer _just one_ of these questions to get credit
 * (though you can answer both if you are feeling adventurous).
 *
 * TODO
 *)

(*** BONUS ***)

(*
 * TODO
 *
 * Error checking
 *
 * Proof production (section & retraction)
 *
 * IDK what else
 *)
